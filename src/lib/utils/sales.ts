// Order type will be generated by Payload
// Using a minimal type definition for now
interface Order {
  id: string
  amount: number | string | { toString: () => string }
  currency?: string
  createdAt?: string
  items?: Array<{
    product?: string | { id: string; title?: string }
    quantity?: number
    price?: number | string | { toString: () => string }
  }>
  customer?: string | { id: string; email?: string }
  customerEmail?: string
  status?: string
}

export interface SalesStats {
  totalRevenue: number
  totalOrders: number
  averageOrderValue: number
  revenueByDate: Array<{ date: string; revenue: number }>
}

export interface ProductSales {
  productId: string
  productTitle: string
  quantitySold: number
  revenue: number
}

/**
 * Calculate total revenue from orders
 */
export function calculateTotalRevenue(orders: Order[]): number {
  return orders.reduce((total, order) => {
    const amount =
      typeof order.amount === 'number' ? order.amount : parseFloat(order.amount?.toString() || '0')
    return total + amount
  }, 0)
}

/**
 * Calculate average order value
 */
export function calculateAverageOrderValue(orders: Order[]): number {
  if (orders.length === 0) return 0
  const totalRevenue = calculateTotalRevenue(orders)
  return totalRevenue / orders.length
}

/**
 * Group orders by date and calculate revenue per day
 */
export function groupOrdersByDate(
  orders: Order[],
  days: number = 30,
): Array<{ date: string; revenue: number }> {
  const dateMap = new Map<string, number>()
  const now = new Date()
  const startDate = new Date(now.getTime() - days * 24 * 60 * 60 * 1000)

  // Initialize all dates with 0
  for (let i = 0; i < days; i++) {
    const date = new Date(startDate.getTime() + i * 24 * 60 * 60 * 1000)
    const dateKey = date.toISOString().split('T')[0]
    dateMap.set(dateKey, 0)
  }

  // Add order amounts to respective dates
  orders.forEach((order) => {
    if (order.createdAt) {
      const orderDate = new Date(order.createdAt)
      if (orderDate >= startDate) {
        const dateKey = orderDate.toISOString().split('T')[0]
        const currentRevenue = dateMap.get(dateKey) || 0
        const amount =
          typeof order.amount === 'number'
            ? order.amount
            : parseFloat(order.amount?.toString() || '0')
        dateMap.set(dateKey, currentRevenue + amount)
      }
    }
  })

  return Array.from(dateMap.entries())
    .map(([date, revenue]) => ({ date, revenue }))
    .sort((a, b) => a.date.localeCompare(b.date))
}

/**
 * Aggregate product sales from orders
 */
export function aggregateProductSales(orders: Order[]): ProductSales[] {
  const productMap = new Map<string, ProductSales>()

  orders.forEach((order) => {
    if (order.items && Array.isArray(order.items)) {
      order.items.forEach((item) => {
        const productId = typeof item.product === 'string' ? item.product : item.product?.id || ''
        const productTitle =
          typeof item.product === 'object' && item.product?.title
            ? item.product.title
            : 'Unknown Product'

        const quantity = item.quantity || 1
        const price =
          typeof item.price === 'number' ? item.price : parseFloat(item.price?.toString() || '0')
        const revenue = quantity * price

        if (productMap.has(productId)) {
          const existing = productMap.get(productId)!
          existing.quantitySold += quantity
          existing.revenue += revenue
        } else {
          productMap.set(productId, {
            productId,
            productTitle,
            quantitySold: quantity,
            revenue,
          })
        }
      })
    }
  })

  return Array.from(productMap.values()).sort((a, b) => b.quantitySold - a.quantitySold)
}

/**
 * Format currency amount
 */
export function formatCurrency(amount: number, currency: string = 'EUR'): string {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }).format(amount)
}

/**
 * Get sales statistics from orders
 */
export function getSalesStats(orders: Order[]): SalesStats {
  const totalRevenue = calculateTotalRevenue(orders)
  const totalOrders = orders.length
  const averageOrderValue = calculateAverageOrderValue(orders)
  const revenueByDate = groupOrdersByDate(orders, 30)

  return {
    totalRevenue,
    totalOrders,
    averageOrderValue,
    revenueByDate,
  }
}
